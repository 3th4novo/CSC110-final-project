"""CSC110 Fall 2020 Final Project, Visualization Module.

Description
===============================
In this part, we uses plotly to produce a dynamic bar graph to demonstrate
ten countries with the highest carbon dioxide emission per person with data
extracted from our data source.

Copyright and Usage Information
===============================
This file is the final project of four students taking CSC110 at the
University of Toronto St. George campus. All forms of distribution
of this code, whether as given or with any changes, are expressly
prohibited.

This file is Copyright (c) 2020 Kevin Cai, Junsong Guo, Yiteng Zhang and Patrick Zhou.
"""
import random
from typing import List
import plotly.graph_objects as go


from plotly.subplots import make_subplots
from convert_to_data import extract_data_from_txt, EmissionPerCapita, read_csv_file, \
    calculate_emission_per_capita
from predict_future_epc import predict_epc


def visualize(epc_data: List[EmissionPerCapita],
              prediction_year: int, title: str, frame_rate: int) -> None:
    """Main function to run the visualization, demonstrates the graph
    generated by all the available past data we have as well as the
    predicted data after prediction_year years.

    Preconditions:
      - frame_rate % (dataset[0].end_year - dataset[0].start_year + 1) == 0
      - epc_data is processed by predict_epc

    Sample usage:
    >>> visualize(emission_per_capita, emissions, 20, "CO2 Emission Data", 1)
    """

    # Set fit with 2 graphs.
    fig = make_subplots(rows=2, cols=1,
                        subplot_titles=('Emission Per Capita (in thousand metric tons)',
                                        'Average Emission Per Capita (in thousand metric tons)'))

    colors = assign_colors(epc_data)  # assign colors to each element.

    # Initialize the two graphs.
    # PS: We believe there is no error in the marker_color line but
    # somehow pycharm insists there is.(We have tried a demo from
    # the official plotly library and pycharm still highlights it.)
    initial_sorted_top_10 = sort_top_10(epc_data, epc_data[0].start_year)
    initial_sorted_colors = get_sorted_colors(colors, initial_sorted_top_10[0])
    fig.add_trace(go.Bar(x=initial_sorted_top_10[0], y=initial_sorted_top_10[1],
                         text=initial_sorted_top_10[0],
                         hoverinfo='none', textposition='outside',
                         texttemplate='%{x}<br>%{y:s}', cliponaxis=False,
                         name='Per Capita in: ' + str(epc_data[0].start_year),
                         marker_color=initial_sorted_colors
                         ), row=1, col=1)

    x_axis = list(range(epc_data[0].start_year, epc_data[0].end_year + prediction_year + 1))
    fig.add_trace(go.Scatter(x=x_axis, y=[0],
                             name='Average Per Capita: ' + str(epc_data[0].start_year)
                             ), row=2, col=1)

    # Produce each frame presented in the animation.
    list_of_frames = []
    average_emission_so_far = []
    for i in range(epc_data[0].start_year, epc_data[0].end_year + prediction_year + 1, frame_rate):

        # Get the sorted top 10 and their corresponding colors for the current frame.
        sorted_top_10 = sort_top_10(epc_data, i)
        sorted_colors = get_sorted_colors(colors, sorted_top_10[0])

        # Append the current year average emission per capita to the accumulator.
        list.append(average_emission_so_far, average_emission(epc_data, i))

        # Append the current frame to list_of_frames using the following style.
        # PS: the same situation happens in this marker_color, too.
        list_of_frames.append(go.Frame(data=[go.Bar(x=sorted_top_10[0], y=sorted_top_10[1],
                                                    text=sorted_top_10[0],
                                                    hoverinfo='none', textposition='outside',
                                                    texttemplate='%{x}<br>%{y:s}', cliponaxis=False,
                                                    name='Per Capita in: ' + str(i),
                                                    marker_color=sorted_colors),
                                             go.Scatter(x=x_axis, y=average_emission_so_far,
                                                        name='Average Per Capita in: ' + str(i))],
                                       traces=[0, 1]))

    fig.frames = list_of_frames

    # Set the layout of the two graphs.
    fig.update_layout(updatemenus=[{'type': 'buttons',
                                    'showactive': False,
                                    'y': 0,
                                    'x': 1.05,
                                    'xanchor': 'left',
                                    'yanchor': 'bottom',
                                    'buttons': [{'label': 'Play',
                                                 'method': 'animate',
                                                 'args': [None]}]}],
                      width=1400, height=750,
                      font={'size': 20},
                      title=title + ' (Predicted after year: ' + str(epc_data[0].end_year) + ')')
    fig.show()


def assign_colors(data: List[EmissionPerCapita]) -> dict:
    """Return a mapping from EmissionPerCapita.name to a
    string representing colors.

    This function Randomly assigns color to each element in the list.
    """
    colors = {}
    for emission in data:
        r = random.randint(1, 255)
        g = random.randint(1, 255)
        b = random.randint(1, 255)
        color = "rgb(" + str(r) + "," + str(g) + "," + str(b) + ")"
        dict.update(colors, {emission.name: color})

    return colors


def get_top_10(data: List[EmissionPerCapita], current_year: int) -> List[EmissionPerCapita]:
    """Return a list of the 10 elements with highest CO2 emission per person in current year.

    Preconditions:
      - current_year >= data[0].start_year
    """

    # Get the first 10 elements in data
    top_10_so_far = []
    for i in range(10):
        top_10_so_far.append(data[i])

    # Get the index for the current year.
    index = current_year - data[0].start_year

    # Mutate top_10_so_far to get the highest 10.
    for emission in data:
        for value in top_10_so_far:
            if value.epc_year[index] < emission.epc_year[index] and emission not in top_10_so_far:
                list.remove(top_10_so_far, value)
                list.append(top_10_so_far, emission)

    return top_10_so_far


def sort_top_10(data: List[EmissionPerCapita], current_year: int) -> List[list]:
    """Return a list of two sorted lists of the top 10 countries' names and
    emission per person from the smallest to the largest.

    Preconditions:
      - current_year >= data[0].start_year
    """
    top_10 = get_top_10(data, current_year)  # Call get_top_10.
    index = current_year - top_10[0].start_year  # Get the index for current_year.
    values = []
    countries = []

    # Get the value of emission per person of each element, and sort the values.
    for emission in top_10:
        values.append(emission.epc_year[index])

    list.sort(values)

    # use the sorted values to get corresponding country names in the same order.
    for value in values:
        for country in data:
            if country.epc_year[index] == value:
                countries.append(country.name)

    return [countries, values]


def get_sorted_colors(colors: dict, sorted_names: list) -> list:
    """Return the corresponding color for each country in the
    order of the sorted top 10.

    Preconditions:
      - colors are the results produced by assign_colors.
      - sorted_names are countries in our dataset.
    """
    sorted_colors = []
    for name in sorted_names:
        list.append(sorted_colors, colors[name])

    return sorted_colors


def average_emission(data: List[EmissionPerCapita], current_year: int) -> float:
    """Return the average emission per capita in current_year."""

    index = current_year - data[0].start_year  # get the index for current year

    # Get all emissions from that year.
    current_year_emissions = []
    for countries in data:
        current_year_emissions.append(countries.epc_year[index])

    average = sum(current_year_emissions) / len(data)
    return average


if __name__ == '__main__':
    emissions = extract_data_from_txt('carbon_emission.txt')
    populations = read_csv_file('population.csv')
    emission_per_capita = calculate_emission_per_capita(emissions, populations, 1960, 2014)

    start_year = emission_per_capita[0].start_year
    end_year = emission_per_capita[0].end_year
    predict_epc(emission_per_capita, start_year, end_year, 20)

    visualize(emission_per_capita, 20, "CO2 Emission Data", 1)

    # import python_ta.contracts
    #
    # python_ta.contracts.check_all_contracts()
    #
    # import doctest
    #
    # doctest.testmod()
    #
    # import python_ta
    #
    # python_ta.check_all(config={
    #     'extra-imports': ['convert_to_data', 'plotly.graph_objects', 'python_ta.contracts',
    #                       'predict_future_epc', 'random', 'plotly.subplots'],
    #     # the names (strs) of imported modules
    #     'allowed-io': [],  # the names (strs) of functions that call print/open/input
    #     'max-line-length': 150,
    #     'disable': ['R1705', 'C0200']
    # })
